(ns com.yakread.app.content
  "Content API with Alfresco integration, Malli schemas, and XTDB storage"
  (:require [clojure.data.json :as json]
            [com.biffweb :as biff]
            ;; [com.yakread.alfresco.client :as alfresco]
            ;; [com.yakread.alfresco.storage :as storage]
            ;; [com.yakread.alfresco.schema :as schema]
            [malli.core :as m]
            [clojure.tools.logging :as log]))

(defn get-fake-homepage-content
  "GET /api/content/fake/homepage - Return fake homepage content"
  [ctx]
  {:status 200
   :headers {"content-type" "application/json"
             "access-control-allow-origin" "*"}
   :body (json/write-str
          {:page "homepage"
           :content [{:id "fake-hello-456"
                     :type "text"
                     :targetComponent "textBlock"
                     :displayOrder 2
                     :status "published"
                     :alfresco {:id "fake-hello-world-456"
                               :name "hello-world.txt"
                               :path "/Web Site/Home Page/hello-world.txt"
                               :type "file"
                               :mimeType "text/plain"
                               :size 13}
                     :createdAt "2025-09-17T09:15:00.000Z"
                     :modifiedAt "2025-09-17T09:15:00.000Z"
                     :content "Hello World from Mt Zion! This text came through the pipeline."}]
           :timestamp (str (biff/now))})})

;; --- ALFRESCO CONTENT ENDPOINTS ---

(defn get-alfresco-homepage-content
  "GET /api/content/alfresco/homepage - Return real homepage content from Alfresco"
  [ctx]
  (try
    (log/info "Fetching homepage content from Alfresco")

    ;; Test connection first
    (if (alfresco/test-connection ctx)
      ;; Search for homepage content in Alfresco
      (let [homepage-content (alfresco/get-yakread-content
                              ctx
                              "PATH:\"/Web Site/Home Page/*\" OR NAME:homepage OR NAME:\"home page\""
                              {:paging {:maxItems 10}})]

        {:status 200
         :headers {"content-type" "application/json"
                   "access-control-allow-origin" "*"}
         :body (json/write-str
                {:page "homepage"
                 :content homepage-content
                 :source "alfresco"
                 :timestamp (str (biff/now))})})

      ;; Fallback to fake content if Alfresco is unavailable
      (do
        (log/warn "Alfresco unavailable, serving fake content")
        (get-fake-homepage-content ctx)))

    (catch Exception e
      (log/error "Error fetching Alfresco content:" (.getMessage e))
      {:status 500
       :headers {"content-type" "application/json"
                 "access-control-allow-origin" "*"}
       :body (json/write-str
              {:error "Failed to fetch content"
               :message (.getMessage e)
               :timestamp (str (biff/now))})})))

(defn get-alfresco-content-by-path
  "GET /api/content/alfresco/path/:path - Return content from specific Alfresco path"
  [ctx]
  (let [path (get-in ctx [:params :path])]
    (try
      (log/info "Fetching content from Alfresco path:" path)

      (if (alfresco/test-connection ctx)
        (let [content (alfresco/get-yakread-content ctx (str "PATH:\"" path "/*\""))]
          {:status 200
           :headers {"content-type" "application/json"
                     "access-control-allow-origin" "*"}
           :body (json/write-str
                  {:path path
                   :content content
                   :source "alfresco"
                   :timestamp (str (biff/now))})})

        {:status 503
         :headers {"content-type" "application/json"
                   "access-control-allow-origin" "*"}
         :body (json/write-str
                {:error "Alfresco service unavailable"
                 :path path
                 :timestamp (str (biff/now))})})

      (catch Exception e
        (log/error "Error fetching content by path:" (.getMessage e))
        {:status 500
         :headers {"content-type" "application/json"
                   "access-control-allow-origin" "*"}
         :body (json/write-str
                {:error "Failed to fetch content"
                 :path path
                 :message (.getMessage e)
                 :timestamp (str (biff/now))})}))))

(defn get-alfresco-health
  "GET /api/content/alfresco/health - Check Alfresco connection health"
  [ctx]
  (try
    (let [health-result (alfresco/health-check ctx)]
      {:status (if (:success health-result) 200 503)
       :headers {"content-type" "application/json"
                 "access-control-allow-origin" "*"}
       :body (json/write-str
              (merge health-result
                     {:timestamp (str (biff/now))}))})

    (catch Exception e
      {:status 500
       :headers {"content-type" "application/json"
                 "access-control-allow-origin" "*"}
       :body (json/write-str
              {:success false
               :error (.getMessage e)
               :timestamp (str (biff/now))})})))

(defn search-alfresco-content
  "POST /api/content/alfresco/search - Search Alfresco content"
  [ctx]
  (try
    (let [body (json/read-str (slurp (:body ctx)) :key-fn keyword)
          query (:query body)
          options (:options body {})]

      (log/info "Searching Alfresco content:" query)

      (if (alfresco/test-connection ctx)
        (let [search-results (alfresco/search-nodes ctx query options)]
          {:status (if (:success search-results) 200 400)
           :headers {"content-type" "application/json"
                     "access-control-allow-origin" "*"}
           :body (json/write-str
                  (merge search-results
                         {:query query
                          :timestamp (str (biff/now))}))})

        {:status 503
         :headers {"content-type" "application/json"
                   "access-control-allow-origin" "*"}
         :body (json/write-str
                {:error "Alfresco service unavailable"
                 :query query
                 :timestamp (str (biff/now))})}))

    (catch Exception e
      (log/error "Error searching Alfresco content:" (.getMessage e))
      {:status 500
       :headers {"content-type" "application/json"
                 "access-control-allow-origin" "*"}
       :body (json/write-str
              {:error "Search failed"
               :message (.getMessage e)
               :timestamp (str (biff/now))})})))

;; --- SCHEMA-INTEGRATED PIPELINE ENDPOINTS ---

(defn sync-alfresco-to-xtdb
  "POST /api/content/alfresco/sync - Sync content from Alfresco to XTDB with schema validation"
  [ctx]
  (try
    (log/info "Starting Alfresco to XTDB sync with schema validation")

    (if (alfresco/test-connection ctx)
      ;; Get content from Alfresco
      (let [root-response (alfresco/get-root-node ctx)]
        (if (:success root-response)
          (let [root-node (get-in root-response [:data :entry])
                ;; Get some sample content (limit to prevent overwhelming)
                children-response (alfresco/get-node-children ctx (:id root-node))
                children (if (:success children-response)
                           (take 10 (get-in children-response [:data :list :entries]))
                           [])

                ;; Extract nodes and sync to XTDB
                nodes (map :entry children)
                sync-results (storage/sync-alfresco-content! ctx nodes)]

            {:status 200
             :headers {"content-type" "application/json"
                       "access-control-allow-origin" "*"}
             :body (json/write-str
                    {:success true
                     :sync-results sync-results
                     :nodes-processed (count nodes)
                     :timestamp (str (biff/now))})})

          {:status 500
           :headers {"content-type" "application/json"
                     "access-control-allow-origin" "*"}
           :body (json/write-str
                  {:error "Failed to get root node from Alfresco"
                   :details (:error root-response)
                   :timestamp (str (biff/now))})}))

      {:status 503
       :headers {"content-type" "application/json"
                 "access-control-allow-origin" "*"}
       :body (json/write-str
              {:error "Alfresco service unavailable"
               :timestamp (str (biff/now))})})

    (catch Exception e
      (log/error "Error in Alfresco to XTDB sync:" (.getMessage e))
      {:status 500
       :headers {"content-type" "application/json"
                 "access-control-allow-origin" "*"}
       :body (json/write-str
              {:error "Sync operation failed"
               :message (.getMessage e)
               :timestamp (str (biff/now))})})))

(defn get-schema-validated-content
  "GET /api/content/schema/page/:page - Get schema-validated content for UIX"
  [ctx]
  (let [page (get-in ctx [:params :page] "homepage")]
    (try
      (log/info "Getting schema-validated content for page:" page)

      ;; Get content from XTDB, transformed and validated for UIX
      (let [uix-content (storage/get-content-for-page ctx page 20)]

        ;; Validate the entire page response
        (let [page-response {:page page
                             :content uix-content
                             :source "xtdb"
                             :timestamp (str (biff/now))}]

          (if (m/validate schema/UIXPageContent page-response)
            {:status 200
             :headers {"content-type" "application/json"
                       "access-control-allow-origin" "*"}
             :body (json/write-str page-response)}

            (do
              (log/error "Page response failed schema validation"
                         "errors:" (schema/explain-validation-error
                                    schema/UIXPageContent page-response))
              {:status 500
               :headers {"content-type" "application/json"
                         "access-control-allow-origin" "*"}
               :body (json/write-str
                      {:error "Response failed schema validation"
                       :page page
                       :timestamp (str (biff/now))})}))))

      (catch Exception e
        (log/error "Error getting schema-validated content:" (.getMessage e))
        {:status 500
         :headers {"content-type" "application/json"
                   "access-control-allow-origin" "*"}
         :body (json/write-str
                {:error "Failed to get content"
                 :page page
                 :message (.getMessage e)
                 :timestamp (str (biff/now))})}))))

(defn get-content-stats-endpoint
  "GET /api/content/stats - Get content statistics and schema validation status"
  [ctx]
  (try
    (let [stats (storage/get-content-stats ctx)
          validation-results (storage/validate-stored-content ctx)]

      {:status 200
       :headers {"content-type" "application/json"
                 "access-control-allow-origin" "*"}
       :body (json/write-str
              {:stats stats
               :validation validation-results
               :schema-registry-size (count schema/yakread-alfresco-registry)
               :timestamp (str (biff/now))})})

    (catch Exception e
      (log/error "Error getting content stats:" (.getMessage e))
      {:status 500
       :headers {"content-type" "application/json"
                 "access-control-allow-origin" "*"}
       :body (json/write-str
              {:error "Failed to get stats"
               :message (.getMessage e)
               :timestamp (str (biff/now))})})))

(defn validate-schema-endpoint
  "POST /api/content/validate - Validate arbitrary data against schemas"
  [ctx]
  (try
    (let [body (json/read-str (slurp (:body ctx)) :key-fn keyword)
          schema-name (:schema body)
          data (:data body)
          schema-key (keyword schema-name)]

      (if-let [schema (get schema/yakread-alfresco-registry schema-key)]
        (let [valid? (m/validate schema data)
              errors (when-not valid?
                       (m/explain schema data))]

          {:status 200
           :headers {"content-type" "application/json"
                     "access-control-allow-origin" "*"}
           :body (json/write-str
                  {:schema-name schema-name
                   :valid? valid?
                   :errors errors
                   :timestamp (str (biff/now))})})

        {:status 400
         :headers {"content-type" "application/json"
                   "access-control-allow-origin" "*"}
         :body (json/write-str
                {:error "Schema not found"
                 :schema-name schema-name
                 :available-schemas (keys schema/yakread-alfresco-registry)
                 :timestamp (str (biff/now))})}))

    (catch Exception e
        (log/error "Error in schema validation:" (.getMessage e))
        {:status 500
         :headers {"content-type" "application/json"
                   "access-control-allow-origin" "*"}
         :body (json/write-str
                {:error "Validation failed"
                 :message (.getMessage e)
                 :timestamp (str (biff/now))})})))

;; --- MTZUIX CONTENT ENDPOINTS ---

(defn get-feature1-content
  "GET /api/mtzuix/feature1 - Get Feature 1 content for mtzUIX homepage"
  [ctx]
  (try
    (log/info "Serving Feature 1 content for mtzUIX")

    ;; For now, read from our generated content file
    ;; Later this will query XTDB directly
    (let [content-file "mtzuix-feature1-content.edn"]
      (if (.exists (clojure.java.io/file content-file))
        (let [feature1-content (clojure.edn/read-string (slurp content-file))
              first-content (first feature1-content)]

          {:status 200
           :headers {"content-type" "application/json"
                     "access-control-allow-origin" "*"}  ; For development
           :body (json/write-str
                  {:success true
                   :component "feature1"
                   :data {:title (:title first-content)
                          :html (:html-content first-content)
                          :text (:text-content first-content)
                          :lastUpdated (:last-updated first-content)
                          :source (:source-info first-content)
                          :componentId (:component-id first-content)}
                   :timestamp (str (biff/now))})})

        ;; Fallback when no content file exists
        {:status 200
         :headers {"content-type" "application/json"
                   "access-control-allow-origin" "*"}
         :body (json/write-str
                {:success true
                 :component "feature1"
                 :data {:title "Feature 1"
                        :html "<p>No content available yet. Run sync_feature1.clj to populate.</p>"
                        :text "No content available yet."
                        :lastUpdated nil
                        :source nil
                        :componentId "homepage-feature1"}
                 :timestamp (str (biff/now))})}))

    (catch Exception e
      (log/error "Error serving Feature 1 content:" (.getMessage e))
      {:status 500
       :headers {"content-type" "application/json"
                 "access-control-allow-origin" "*"}
       :body (json/write-str
              {:success false
               :error "Failed to load Feature 1 content"
               :message (.getMessage e)
               :timestamp (str (biff/now))})})))

;; --- MODULE DEFINITION ---

(def module
  {:api-routes [;; Fake content for testing
                ["/api/content/fake/homepage" {:get get-fake-homepage-content}]

                ;; Real Alfresco content (direct API)
                ["/api/content/alfresco/homepage" {:get get-alfresco-homepage-content}]
                ["/api/content/alfresco/path/:path" {:get get-alfresco-content-by-path}]
                ["/api/content/alfresco/health" {:get get-alfresco-health}]
                ["/api/content/alfresco/search" {:post search-alfresco-content}]

                ;; Schema-integrated pipeline (Alfresco → XTDB → UIX)
                ["/api/content/alfresco/sync" {:post sync-alfresco-to-xtdb}]
                ["/api/content/schema/page/:page" {:get get-schema-validated-content}]

                ;; Admin and debugging endpoints
                ["/api/content/stats" {:get get-content-stats-endpoint}]
                ["/api/content/validate" {:post validate-schema-endpoint}]

                ;; mtzUIX content endpoints
                ["/api/mtzuix/feature1" {:get get-feature1-content}]]})